# Scaffold Generator

The scaffold generator turns a CF Architect diagram into a downloadable ZIP containing a ready-to-run Cloudflare Workers project. It is implemented entirely client-side — no server API is needed.

## How It Works

1. The user clicks the **Export Project Scaffold** button in the toolbar (available in both the editor and shared read-only view).
2. `ScaffoldButton` reads nodes and edges from the Zustand store.
3. `generateScaffold()` in `src/lib/scaffold.ts` walks the graph:
   - Each node's `typeId` is looked up in the catalog (`src/lib/catalog.ts`) to get its `wranglerBinding` and `scaffoldTemplate` values.
   - Storage/service nodes are grouped by `wranglerBinding` type. The user-assigned label is sanitized into a `SCREAMING_SNAKE_CASE` binding name and a `kebab-case` resource name.
   - A `wrangler.toml` is generated programmatically with all binding sections.
   - A `package.json` is generated with the correct dependencies and deploy scripts.
   - Template files are included verbatim from the `scaffold-templates/` directory.
4. The file map is zipped with `fflate` and downloaded as a `.zip` file.

## Template Directory

```
src/lib/scaffold-templates/
├── vanilla/
│   └── src/index.ts              # Minimal fetch handler
├── hono/
│   └── src/index.ts              # Hono app with route stubs
├── astro/
│   ├── astro.config.mjs          # Astro + Cloudflare adapter
│   └── src/pages/index.astro     # Starter page
├── drizzle/
│   ├── drizzle.config.ts         # Drizzle Kit config for D1
│   ├── src/db/schema.ts          # Placeholder table
│   └── src/db/client.ts          # Helper: drizzle(env.DB)
├── migrations/
│   └── 0001_initial.sql          # Stub migration
├── README.md.tmpl                # Pro-forma README with conditional sections
└── tsconfig.json                 # Base tsconfig for generated projects
```

### Editing Templates

Template files are real source files with full syntax highlighting and IDE support. Edit them directly — no string escaping or quoting needed.

They are imported into `scaffold.ts` via Vite's `?raw` suffix:

```ts
import vanillaIndex from "./scaffold-templates/vanilla/src/index.ts?raw";
```

This inlines the file content as a string at build time.

**Important**: The `scaffold-templates/` directory is excluded from ESLint in `eslint.config.mjs` because these files are not part of the CF Architect app itself — they're templates for generated projects.

### Programmatically Generated Files

Two files are generated by code rather than templates because their content depends on the specific diagram:

- **`wrangler.toml`** — Binding sections are assembled from the diagram's nodes. Each `wranglerBinding` type has a section emitter in `scaffold.ts`.
- **`package.json`** — Dependencies and scripts vary based on the scaffold template (vanilla/hono/astro) and whether D1 is present.

### README Template Markers

`README.md.tmpl` uses `{{MARKER}}` placeholders for conditional content:

| Marker                                                            | Purpose                                  |
| ----------------------------------------------------------------- | ---------------------------------------- |
| `{{PROJECT_NAME}}`                                                | Replaced with the sanitized project name |
| `{{D1_LOCAL_SECTION_START}}` / `{{D1_LOCAL_SECTION_END}}`         | Wraps the local D1 setup instructions    |
| `{{D1_DEPLOY_SECTION_START}}` / `{{D1_DEPLOY_SECTION_END}}`       | Wraps the D1 deploy explanation          |
| `{{NO_D1_DEPLOY_SECTION_START}}` / `{{NO_D1_DEPLOY_SECTION_END}}` | Wraps the non-D1 deploy explanation      |
| `{{D1_LINKS_START}}` / `{{D1_LINKS_END}}`                         | Wraps D1/Drizzle doc links               |

When D1 is present, the D1 sections are kept and the NO_D1 sections are stripped. When D1 is absent, the reverse happens.

## Adding a New Template

1. Create a new directory under `src/lib/scaffold-templates/` (e.g. `remix/`).
2. Add the template files (e.g. `remix/src/index.ts`, `remix/remix.config.js`).
3. In `src/lib/scaffold.ts`, add `?raw` imports for each new file.
4. Add a `case` to the `switch (scaffoldTemplate)` block to emit the files.
5. In `src/lib/catalog.ts`, add or update a node type with `scaffoldTemplate: "remix"`.
6. Add any framework-specific dependencies to the `generatePackageJson` function.

## Binding Resolution

User-assigned node labels are converted to binding names and resource names:

| Input Label        | Binding Name (SCREAMING_SNAKE) | Resource Name (kebab) |
| ------------------ | ------------------------------ | --------------------- |
| `My D1 Database`   | `MY_D1_DATABASE`               | `my-d1-database`      |
| `Cache Store`      | `CACHE_STORE`                  | `cache-store`         |
| `user-data (prod)` | `USERDATA_PROD`                | `userdata-prod`       |

Singleton bindings like `ai` and `browser` use fixed binding names (`AI`, `BROWSER`).

## Deploy Scripts

The generated `package.json` includes orchestrated deploy scripts via `npm-run-all`:

**Without D1:**

```
"deploy": "run-s deploy:cf"
"deploy:cf": "wrangler deploy"
```

**With D1:**

```
"deploy": "run-s deploy:db deploy:cf"
"deploy:db": "wrangler d1 migrations apply <BINDING> --remote"
"deploy:cf": "wrangler deploy"
"db:generate": "drizzle-kit generate"
"db:migrate:local": "wrangler d1 migrations apply <BINDING> --local"
```

## Testing

Unit tests for the scaffold generator live in `tests/unit/lib/scaffold.test.ts`. Run them with:

```bash
npx vitest run tests/unit/lib/scaffold.test.ts
```
